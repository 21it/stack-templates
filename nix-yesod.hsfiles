{-# START_FILE .dir-locals.el #-}
((haskell-mode . ((haskell-indent-spaces . 4)
                  (haskell-process-use-ghci . t)))
 (hamlet-mode . ((hamlet/basic-offset . 4)
                 (haskell-process-use-ghci . t))))

{-# START_FILE package.yaml #-}
name:                {{name}}
version:             0.1.0.0
github:              "{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}"
license:             BSD3
author:              "{{author-name}}{{^author-name}}Author name here{{/author-name}}"
maintainer:          "{{author-email}}{{^author-email}}example@example.com{{/author-email}}"
copyright:           "{{copyright}}{{^copyright}}{{year}}{{^year}}2019{{/year}} {{author-name}}{{^author-name}}Author name here{{/author-name}}{{/copyright}}"

extra-source-files:
- README.md
- ChangeLog.md

# Metadata used when publishing your package
# synopsis:            Short description of your package
# category:            {{category}}{{^category}}Web{{/category}}

# To avoid duplicated efforts in documentation and dealing with the
# complications of embedding Haddock markup inside cabal files, it is
# common to point users to the README.md file.
description:         Please see the README on GitHub at <https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}#readme>

dependencies:
- base >=4.9.1.0 && <5
- yesod >=1.6 && <1.7
- yesod-core >=1.6 && <1.7
- yesod-auth >=1.6 && <1.7
- yesod-static >=1.6 && <1.7
- yesod-form >=1.6 && <1.7
- classy-prelude >=1.5 && <1.6
- classy-prelude-conduit >=1.5 && <1.6
- classy-prelude-yesod >=1.5 && <1.6
- bytestring >=0.10 && <0.11
- text >=0.11 && <2.0
- persistent >=2.9 && <2.11
- persistent-postgresql >=2.9 && <2.11
- persistent-template >=2.5 && <2.9
- template-haskell
- shakespeare >=2.0 && <2.1
- hjsmin >=0.1 && <0.3
- monad-control >=0.3 && <1.1
- wai-extra >=3.0 && <3.1
- yaml >=0.11 && <0.12
- http-client-tls >=0.3 && <0.4
- http-conduit >=2.3 && <2.4
- directory >=1.1 && <1.4
- warp >=3.0 && <3.4
- data-default
- aeson >=1.4 && <1.5
- conduit >=1.0 && <2.0
- monad-logger >=0.3 && <0.4
- fast-logger >=2.2 && <3.1
- wai-logger >=2.2 && <2.4
- file-embed
- safe
- unordered-containers
- containers
- vector
- time
- case-insensitive
- wai
- foreign-store

# The library contains all of our application code. The executable
# defined below is just a thin wrapper.
library:
  source-dirs: src
  # TODO : remove dependencies if not needed
  dependencies:
  - hspec
  - hspec-wai
  when:
  - condition: (flag(dev)) || (flag(library-only))
    then:
      ghc-options:
      # For details on warnings: https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
      # Enable all warnings with -Weverything, then disable the ones we don’t care about
      - -Weverything
      - -Werror
      - -Wno-missing-exported-signatures # missing-exported-signatures turns off the more strict -Wmissing-signatures. See https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
      - -Wno-missing-import-lists # Requires explicit imports of _every_ function (e.g. ‘$’); too strict
      - -Wno-missed-specialisations # When GHC can’t specialize a polymorphic function. No big deal and requires fixing underlying libraries to solve.
      - -Wno-all-missed-specialisations # See missed-specialisations
      - -Wno-unsafe # Don’t use Safe Haskell warnings
      - -Wno-safe # Don’t use Safe Haskell warnings
      - -Wno-missing-local-signatures # Warning for polymorphic local bindings; nothing wrong with those.
      - -Wno-monomorphism-restriction # Don’t warn if the monomorphism restriction is used
      - -Wno-implicit-prelude
      - -O0
      cpp-options: -DDEVELOPMENT
    else:
      ghc-options:
      # For details on warnings: https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
      # Enable all warnings with -Weverything, then disable the ones we don’t care about
      - -Weverything
      - -Werror
      - -Wno-missing-exported-signatures # missing-exported-signatures turns off the more strict -Wmissing-signatures. See https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
      - -Wno-missing-import-lists # Requires explicit imports of _every_ function (e.g. ‘$’); too strict
      - -Wno-missed-specialisations # When GHC can’t specialize a polymorphic function. No big deal and requires fixing underlying libraries to solve.
      - -Wno-all-missed-specialisations # See missed-specialisations
      - -Wno-unsafe # Don’t use Safe Haskell warnings
      - -Wno-safe # Don’t use Safe Haskell warnings
      - -Wno-missing-local-signatures # Warning for polymorphic local bindings; nothing wrong with those.
      - -Wno-monomorphism-restriction # Don’t warn if the monomorphism restriction is used
      - -Wno-implicit-prelude
      - -O2

# Runnable executable for our application
executables:
  {{name}}:
    main: main.hs
    source-dirs: app
    ghc-options:
    # For details on warnings: https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
    # Enable all warnings with -Weverything, then disable the ones we don’t care about
    - -Weverything
    - -Werror
    - -Wno-missing-exported-signatures # missing-exported-signatures turns off the more strict -Wmissing-signatures. See https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
    - -Wno-missing-import-lists # Requires explicit imports of _every_ function (e.g. ‘$’); too strict
    - -Wno-missed-specialisations # When GHC can’t specialize a polymorphic function. No big deal and requires fixing underlying libraries to solve.
    - -Wno-all-missed-specialisations # See missed-specialisations
    - -Wno-unsafe # Don’t use Safe Haskell warnings
    - -Wno-safe # Don’t use Safe Haskell warnings
    - -Wno-missing-local-signatures # Warning for polymorphic local bindings; nothing wrong with those.
    - -Wno-monomorphism-restriction # Don’t warn if the monomorphism restriction is used
    - -Wno-implicit-prelude
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - {{name}}
    when:
    - condition: flag(library-only)
      buildable: false

# Test suite
tests:
  {{name}}-test:
    main: Spec.hs
    source-dirs: test
    ghc-options:
    # For details on warnings: https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
    # Enable all warnings with -Weverything, then disable the ones we don’t care about
    - -Weverything
    - -Werror
    - -Wno-missing-exported-signatures # missing-exported-signatures turns off the more strict -Wmissing-signatures. See https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
    - -Wno-missing-import-lists # Requires explicit imports of _every_ function (e.g. ‘$’); too strict
    - -Wno-missed-specialisations # When GHC can’t specialize a polymorphic function. No big deal and requires fixing underlying libraries to solve.
    - -Wno-all-missed-specialisations # See missed-specialisations
    - -Wno-unsafe # Don’t use Safe Haskell warnings
    - -Wno-safe # Don’t use Safe Haskell warnings
    - -Wno-missing-local-signatures # Warning for polymorphic local bindings; nothing wrong with those.
    - -Wno-monomorphism-restriction # Don’t warn if the monomorphism restriction is used
    - -Wno-implicit-prelude
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - {{name}}
    - hspec >=2.0.0
    - hspec-wai
    - yesod-test

# Define flags used by "yesod devel" to make compilation faster
flags:
  library-only:
    description: Build for use with "yesod devel"
    manual: false
    default: false
  dev:
    description: Turn on development settings, like auto-reload templates.
    manual: false
    default: false

{-# START_FILE Setup.hs #-}
import Distribution.Simple
main = defaultMain

{-# START_FILE test/Spec.hs #-}
{-# OPTIONS_GHC -Wno-missing-export-lists #-}
{-# OPTIONS_GHC -F -pgmF hspec-discover #-}

{-# START_FILE app/main.hs #-}
import Prelude     (IO)
import Application (appMain)

main :: IO ()
main = appMain

{-# START_FILE README.md #-}
# {{name}}
## Database Setup (without Nix)

After installing Postgres, run:

```
createuser {{name}} --pwprompt --superuser
# Enter password {{name}} when prompted
createdb {{name}}
createdb {{name}}_test
```

## Haskell Setup (without Nix)

1. If you haven't already, [install Stack](https://haskell-lang.org/get-started)
	* On POSIX systems, this is usually `curl -sSL https://get.haskellstack.org/ | sh`
2. Install the `yesod` command line tool: `stack install yesod-bin --install-ghc`
3. Build libraries: `stack build`

If you have trouble, refer to the [Yesod Quickstart guide](https://www.yesodweb.com/page/quickstart) for additional detail.

## Development

Start a development server with:

```
stack exec -- yesod devel
```

As your code changes, your site will be automatically recompiled and redeployed to localhost.

## Tests

```
stack test --flag {{name}}:library-only --flag {{name}}:dev
```

(Because `yesod devel` passes the `library-only` and `dev` flags, matching those flags means you don't need to recompile between tests and development, and it disables optimization to speed up your test compile times).

## Documentation

* Read the [Yesod Book](https://www.yesodweb.com/book) online for free
* Check [Stackage](http://stackage.org/) for documentation on the packages in your LTS Haskell version, or [search it using Hoogle](https://www.stackage.org/lts/hoogle?q=). Tip: Your LTS version is in your `stack.yaml` file.
* For local documentation, use:
	* `stack haddock --open` to generate Haddock documentation for your dependencies, and open that documentation in a browser
	* `stack hoogle <function, module or type signature>` to generate a Hoogle database and search for your query
* The [Yesod cookbook](https://github.com/yesodweb/yesod-cookbook) has sample code for various needs

## Getting Help

* Ask questions on [Stack Overflow, using the Yesod or Haskell tags](https://stackoverflow.com/questions/tagged/yesod+haskell)
* Ask the [Yesod Google Group](https://groups.google.com/forum/#!forum/yesodweb)
* There are several chatrooms you can ask for help:
	* For IRC, try Freenode#yesod and Freenode#haskell
	* [Functional Programming Slack](https://fpchat-invite.herokuapp.com/), in the #haskell, #haskell-beginners, or #yesod channels.

{-# START_FILE ChangeLog.md #-}
# Changelog for {{name}}

## Unreleased changes

{-# START_FILE LICENSE #-}
Copyright {{author-name}}{{^author-name}}Author name here{{/author-name}} (c) {{year}}{{^year}}2019{{/year}}

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of {{author-name}}{{^author-name}}Author name here{{/author-name}} nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

{-# START_FILE .gitignore #-}
pkg.nix
nix/pkg.nix
result
postgres
postgres_data
postgres.log
dist*
static/tmp/
static/combined/
config/client_session_key.aes
*.hi
*.o
*.sqlite3
*.sqlite3-shm
*.sqlite3-wal
.hsenv*
cabal-dev/
.stack-work/
.stack-work-devel/
yesod-devel/
.cabal-sandbox
cabal.sandbox.config
.DS_Store
*.swp
*.keter
*~
\#*
{{name}}.cabal

{-# START_FILE .ignore #-}
.stack-work

{-# START_FILE ./nix/default.nix #-}
{
  pkgs ? null,
  hexOrganization ? null, # organization account name on hex.pm
  hexApiKey ? null,       # plain text account API key on hex.pm
  robotSshKey ? null      # base64-encoded private id_rsa (for private git)
}:
let overlays = [
      (import ./overlay.nix {inherit hexOrganization hexApiKey robotSshKey;})
    ];
    localPkgs = import ./nixpkgs.nix;
    nixpkgs = if pkgs == null then import localPkgs {inherit overlays;} else pkgs;
in
with nixpkgs;

let callPackage = lib.callPackageWith haskellPackages;
    pkg = callPackage ./pkg.nix {inherit stdenv;};
    systemDeps = [ protobuf makeWrapper cacert ];
    testDeps = [ postgresql ];
in
  haskell.lib.overrideCabal pkg (drv: {
    setupHaskellDepends =
      if drv ? "setupHaskellDepends"
      then drv.setupHaskellDepends ++ systemDeps
      else systemDeps;
    testSystemDepends =
      if drv ? "testSystemDepends"
      then drv.testSystemDepends ++ testDeps
      else testDeps;
    isExecutable = true;
    enableSharedExecutables = false;
    enableLibraryProfiling = false;
    isLibrary = false;
    doHaddock = false;
    preCheck = ''
      source ./nix/export-test-envs.sh;
      sh ./nix/reset-test-data.sh;
      sh ./nix/spawn-test-deps.sh;
    '';
    postCheck = ''
      sh ./nix/shutdown-test-deps.sh
    '';
    postFixup = "rm -rf $out/lib $out/nix-support $out/share/doc";
    postInstall = ''
      wrapProgram "$out/bin/{{name}}-exe" \
        --set SYSTEM_CERTIFICATE_PATH "${cacert}/etc/ssl/certs"
    '';
  })

{-# START_FILE ./nix/docker.nix #-}
let nixpkgs = import ./nixpkgs.nix;
in
{
  pkgs ? import nixpkgs {},
  hexOrganization ? null, # organization account name on hex.pm
  hexApiKey ? null,       # plain text account API key on hex.pm
  robotSshKey ? null      # base64-encoded private id_rsa (for private git)
}:
let pkg = import ./default.nix {inherit hexOrganization hexApiKey robotSshKey;};
in
with pkgs;

dockerTools.buildImage {
  name = "{{organization}}{{^organization}}TODO_ADD_ORGANIZATION{{/organization}}/{{name}}";
  contents = [ pkg ];

  config = {
    Cmd = [ "${pkg}/bin/{{name}}-exe" ];
    ExposedPorts = {
      "80/tcp" = {};
    };
  };
}

{-# START_FILE ./nix/nixpkgs.nix #-}
builtins.fetchTarball {
  url="https://github.com/NixOS/nixpkgs/archive/19.09-beta.tar.gz";
  sha256="0fplfm2zx4vk7gs8bdcxnvzkdmpx2w0llqwf8475z9dz9cl132rm";
}

{-# START_FILE ./nix/overlay.nix #-}
{
  hexOrganization,
  hexApiKey,
  robotSshKey
}:
self: super:
  let
    callPackage = self.lib.callPackageWith self.haskellPackages;
    dontCheck = self.haskell.lib.dontCheck;
    doJailbreak = self.haskell.lib.doJailbreak;
    persistent-migration = callPackage ./persistent-migration.nix {
      stdenv = self.stdenv;
      fetchgit = self.fetchgit;
    };
    hspec-wai = callPackage
      ({ mkDerivation, base, base-compat, bytestring, case-insensitive
       , hspec, hspec-core, hspec-expectations, http-types, QuickCheck
       , text, transformers, wai, wai-extra
       }:
       mkDerivation {
         pname = "hspec-wai";
         version = "0.10.1";
         sha256 = "05jv0cz8r8bf63ma5byjb2gkj9vwgnls4n9mks99qc525n055ckz";
         libraryHaskellDepends = [
           base base-compat bytestring case-insensitive hspec-core
           hspec-expectations http-types QuickCheck text transformers wai
           wai-extra
         ];
         testHaskellDepends = [
           base base-compat bytestring case-insensitive hspec hspec-core
           hspec-expectations http-types QuickCheck text transformers wai
           wai-extra
         ];
         description = "Experimental Hspec support for testing WAI applications";
         license = self.stdenv.lib.licenses.mit;
       }) {};
    hspec-wai-json = callPackage
      ({ mkDerivation, aeson, aeson-qq, base, bytestring
       , case-insensitive, hspec, hspec-wai, template-haskell
       }:
       mkDerivation {
         pname = "hspec-wai-json";
         version = "0.10.1";
         sha256 = "04mpqij446ki5l6xwi3bjmlf3ggjia2nzv8j62mdy6ick96dqwk6";
         libraryHaskellDepends = [
           aeson aeson-qq base bytestring case-insensitive hspec-wai
           template-haskell
         ];
         testHaskellDepends = [ base hspec hspec-wai ];
         description = "Testing JSON APIs with hspec-wai";
         license = self.stdenv.lib.licenses.mit;
       }) {};
    scotty = callPackage
      ({ mkDerivation, aeson, async, base, blaze-builder, bytestring
       , case-insensitive, data-default-class, directory, exceptions, fail
       , hspec, hspec-discover, hspec-wai, http-types, lifted-base
       , monad-control, mtl, nats, network, regex-compat, text
       , transformers, transformers-base, transformers-compat, wai
       , wai-extra, warp
       }:
       mkDerivation {
         pname = "scotty";
         version = "0.11.5";
         sha256 = "1pyj7j3zk80lv1c62ccna7nrsql5wf7pi5jscmypr2zd5xgfffvg";
         libraryHaskellDepends = [
           aeson base blaze-builder bytestring case-insensitive
           data-default-class exceptions fail http-types monad-control mtl
           nats network regex-compat text transformers transformers-base
           transformers-compat wai wai-extra warp
         ];
         testHaskellDepends = [
           async base bytestring data-default-class directory hspec hspec-wai
           http-types lifted-base network text wai
         ];
         testToolDepends = [ hspec-discover ];
         description = "Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp";
         license = self.stdenv.lib.licenses.bsd3;
       }) {};
  in
    {
      haskellPackages = super.haskell.packages.ghc865.extend(
        self': super': {
          proto3-suite = dontCheck (doJailbreak super'.proto3-suite);
          hspec-wai = hspec-wai;
          hspec-wai-json = hspec-wai-json;
          scotty = scotty;
          persistent-migration = dontCheck persistent-migration;
        }
      );
    }

{-# START_FILE ./nix/persistent-migration.nix #-}
{ mkDerivation, base, bytestring, conduit, containers, exceptions
, fetchgit, fgl, hpack, monad-logger, mtl, persistent
, persistent-postgresql, persistent-template, process, QuickCheck
, resource-pool, stdenv, tasty, tasty-golden, tasty-quickcheck
, temporary, text, time, unordered-containers, yaml
}:
mkDerivation {
  pname = "persistent-migration";
  version = "0.1.0";
  src = fetchgit {
    url = "https://github.com/coingaming/persistent-migration.git";
    sha256 = "1zs4457q76xxpx1br1xjnh65xcl6bm2zkxjadi92vng7qm7p5z6n";
    rev = "fea2e971b5102f5068021937dbf4ee3bcb42dd1e";
    fetchSubmodules = true;
  };
  libraryHaskellDepends = [
    base containers fgl mtl persistent text time unordered-containers
  ];
  libraryToolDepends = [ hpack ];
  testHaskellDepends = [
    base bytestring conduit containers exceptions monad-logger mtl
    persistent persistent-postgresql persistent-template process
    QuickCheck resource-pool tasty tasty-golden tasty-quickcheck
    temporary text time yaml
  ];
  prePatch = "hpack";
  homepage = "https://github.com/brandonchinn178/persistent-migration#readme";
  description = "Manual migrations for the persistent library";
  license = stdenv.lib.licenses.bsd3;
}

{-# START_FILE ./nix/shell.nix #-}
let nixpkgs = import ./nixpkgs.nix;
in
{
  pkgs ? null,
  hexOrganization ? null, # organization account name on hex.pm
  hexApiKey ? null,       # plain text account API key on hex.pm
  robotSshKey ? null      # base64-encoded private id_rsa (for private git)
}:
let overlays = [
      (import ./overlay.nix {inherit hexOrganization hexApiKey robotSshKey;})
    ];
    pkgs' = if pkgs == null
            then import nixpkgs {inherit overlays;}
            else pkgs;
in
with pkgs';

let haskell-ide = import (
      fetchTarball "https://github.com/tim2CF/ultimate-haskell-ide/tarball/master"
    ) {};
in

stdenv.mkDerivation {
  name = "{{name}}-env";
  buildInputs = [
    /* IDE */
    haskell-ide
    /* Apps */
    postgresql
    /* Utils */
    git
    nix-prefetch-scripts
    openssh
    cabal2nix
    protobuf
    cacert
    xxd
  ];

  TERM="xterm-256color";
  GIT_SSL_CAINFO="${cacert}/etc/ssl/certs/ca-bundle.crt";
  NIX_SSL_CERT_FILE="${cacert}/etc/ssl/certs/ca-bundle.crt";
  NIX_PATH="/nix/var/nix/profiles/per-user/root/channels";
  HEX_ORGANIZATION=hexOrganization;
  HEX_API_KEY=hexApiKey;
  ROBOT_SSH_KEY=robotSshKey;
  shellHook = ''
    source ./nix/export-test-envs.sh
    sh ./nix/reset-test-data.sh
    sh ./nix/spawn-test-deps.sh

    export HOOGLEDB=/root/.hoogle
    if [ "$(ls -A $HOOGLEDB)" ]; then
      echo "hoogle database already exists..."
    else
      echo "building hoogle database..."
      stack --stack-yaml=/app/stack.yaml exec hoogle generate
    fi
  '';
}

{-# START_FILE ./nix/bootstrap.sh #-}
#/bin/sh

set -e

export PATH=/nix/var/nix/profiles/default/bin:/nix/var/nix/profiles/default/sbin:$PATH

# Disable HTTP2 (related to https://github.com/NixOS/nix/issues/2733)
echo 'http2 = false' >> /etc/nix/nix.conf
nix-channel --add https://nixos.org/channels/nixos-19.09 nixpkgs
nix-channel --update
nix-env -iAP nixpkgs.openssh nixpkgs.git nixpkgs.cabal2nix nixpkgs.coreutils nixpkgs.docker
nix-env -iAP cachix -f https://cachix.org/api/v1/install
cachix use all-hies

mkdir -p /tmp/.ssh/
mkdir -p $HOME/.ssh/
echo "$ROBOT_SSH_KEY" | base64 -d > /tmp/.ssh/id_rsa.robot
chmod 600 /tmp/.ssh/id_rsa.robot
eval `ssh-agent -s`
ssh-add /tmp/.ssh/id_rsa.robot
echo -e "Host *\n IdentityFile /tmp/.ssh/id_rsa.robot\n IdentitiesOnly yes\n UserKnownHostsFile /tmp/.ssh/known_hosts\n StrictHostKeyChecking no" > /tmp/.ssh/config
ssh-keyscan github.com >> /tmp/.ssh/known_hosts
cp /tmp/.ssh/* $HOME/.ssh/
echo -e "Host *\n IdentityFile $HOME/.ssh/id_rsa.robot\n IdentitiesOnly yes\n UserKnownHostsFile $HOME/.ssh/known_hosts\n StrictHostKeyChecking no" > $HOME/.ssh/config
chown -R nixbld1 /tmp/.ssh/
git submodule update --init --recursive --depth 1

{-# START_FILE ./nix/export-test-envs.sh #-}
#!/bin/sh

#
# app
#

export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_ENV="dev";
export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_LOG_FORMAT="Bracket"; # Bracket | JSON
export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_LIBPQ_CONN_STR="postgresql://nixbld1@localhost/{{name}}";
export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_ENDPOINT_PORT="4000";

{-# START_FILE ./nix/release.sh #-}
#!/bin/sh

set -e

./nix/bootstrap.sh

(cd ./nix/ && cabal2nix ./.. > ./pkg.nix)

NIXPKGS_ALLOW_BROKEN=1 nix-build ./nix/docker.nix \
  -I ssh-config-file=/tmp/.ssh/config \
  --argstr hexOrganization {{organization}}{{^organization}}TODO_ADD_ORGANIZATION{{/organization}} \
  --argstr hexApiKey $HEX_API_KEY \
  --argstr robotSshKey $ROBOT_SSH_KEY \
  --option sandbox false \
  -v --show-trace

{-# START_FILE ./nix/reset-test-data.sh #-}
#!/bin/sh

echo "resetting dev data..."
rm -rf $PGDATA
echo "dev data has been reset!"

{-# START_FILE ./nix/minimal.sh #-}
#!/bin/sh

docker run -it --rm \
  -v "$(pwd):/app" \
  -v "nix:/nix" \
  -w "/app" nixos/nix:2.3

{-# START_FILE ./nix/shell.sh #-}
#!/bin/sh

export IP=$(ifconfig en0 | grep inet | awk '$1=="inet" {print $2}')
echo "host is $IP"
echo "starting nixos container..."
# enable for GUI apps
# xhost + $IP
docker run -it --rm \
  -e DISPLAY=$IP:0 \
  -e NIXPKGS_ALLOW_BROKEN=1 \
  -e ROBOT_SSH_KEY="$ROBOT_SSH_KEY" \
  -v "$(pwd):/app" \
  -v "nix:/nix" \
  -v "stack:/root/.stack" \
  -v "cabal:/root/.cabal" \
  -v "hoogle:/root/.hoogle" \
  -w "/app" nixos/nix:2.3 sh -c "
  ./nix/bootstrap.sh &&
  nix-shell ./nix/shell.nix --pure \
   -I ssh-config-file=/tmp/.ssh/config \
   --argstr hexOrganization $HEX_ORGANIZATION \
   --argstr hexApiKey $HEX_API_KEY \
   --argstr robotSshKey $ROBOT_SSH_KEY \
   --option sandbox false \
   -v --show-trace
  "

{-# START_FILE ./nix/shutdown-test-deps.sh #-}
#!/bin/sh

set -m

export PATH=$PATH:/bin/
export PGDATA=$PWD/postgres
export PGHOST=/tmp/postgres
export PGLOG=$PWD/postgres/LOG
export PGDATABASE=postgres
export DATABASE_URL="postgresql:///postgres?host=$PGHOST"

#
# Postgres
#

if [[ $EUID -ne 0 ]]; then
    alias postgres-sh="sh"
else
    alias postgres-sh="su -m nixbld1"
fi

echo "shutdown postgres..."
postgres-sh -c 'pg_ctl stop -o "-c unix_socket_directories=$PGHOST"'
echo "shutdown hook executed"

{-# START_FILE ./nix/spawn-test-deps.sh #-}
#!/bin/sh

set -m

export PATH=$PATH:/bin/
export PGDATA=$PWD/postgres
export PGHOST=/tmp/postgres
export PGLOG=$PWD/postgres/LOG
export PGDATABASE=postgres
export DATABASE_URL="postgresql:///postgres?host=$PGHOST"

#
# Postgres
#

if [[ $EUID -ne 0 ]]; then
    alias postgres-sh="sh"
else
    alias postgres-sh="su -m nixbld1"
fi

if [ ! -d $PGHOST ]; then
  echo 'initializing postgresql workspace...'
  postgres-sh -c "mkdir -p $PGHOST"
fi
if [ ! -d $PGDATA ]; then
  echo 'initializing postgresql database...'
  postgres-sh -c "mkdir -p $PGDATA"
  postgres-sh -c 'initdb $PGDATA --encoding=UTF8 --auth=trust >/dev/null'
fi

echo "starting postgres..."
postgres-sh -c 'pg_ctl start -o "-c listen_addresses=localhost -c unix_socket_directories=$PGHOST"'

# NOTE : some Postgres bullshit - it crashes if createdb is executed too soon
echo "sleeping for 3s to prevent postgres/createdb race condition..."
sleep 3

postgres-sh -c 'createdb {{name}}'
echo "spawn-test-deps executed"

{-# START_FILE hie.yaml #-}
cradle:
  stack:

{-# START_FILE .vim/coc-settings.json #-}
{
    "languageserver": {
        "haskell": {
            "command": "hie-wrapper",
            "rootPatterns": [
                "*.cabal",
                "stack.yaml",
                "cabal.project",
                "package.yaml"],
                "filetypes": [
                    "hs",
                    "lhs",
                    "haskell"
                ],
                "initializationOptions": {
                    "languageServerHaskell": {
                    }
                }
        }
    }
}

{-# START_FILE .circleci/config.yml #-}
configure: &configure
  docker:
  - image: nixos/nix:2.3
  resource_class: xlarge

release: &release
  run:
    name: Create release
    command: ./nix/release.sh
    no_output_timeout: 60m

filters: &filters
  filters:
    branches: {}

version: 2
jobs:
  release:
    <<: *configure
    steps:
    - checkout
    - setup_remote_docker
    - *release
  release-publish:
    <<: *configure
    steps:
    - checkout
    - setup_remote_docker
    - *release
    - run:
        name: Load docker image
        command: docker load -i result
    - run:
        name: Login docker
        command: echo -e "$DOCKER_PASS" | docker login -u $DOCKER_USER --password-stdin
    - run:
        name: Push docker image
        command: docker push "$(docker images {{organization}}{{^organization}}TODO_ADD_ORGANIZATION{{/organization}}/{{name}} --format "{{=<% %>=}}{{.Repository}}:{{.Tag}}<%={{ }}=%>")"

workflows:
  version: 2
  nightly:
    triggers:
      - schedule:
          <<: *filters
          cron: "0 5 * * *"  # 05:00 UTC
    jobs:
      - release:
          <<: *filters
          context: global
  push:
    jobs:
      - release-publish:
          <<: *filters
          context: global
