{-# START_FILE package.yaml #-}
name:                {{name}}
version:             0.1.0.0
github:              "{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}"
license:             BSD3
author:              "{{author-name}}{{^author-name}}Author name here{{/author-name}}"
maintainer:          "{{author-email}}{{^author-email}}example@example.com{{/author-email}}"
copyright:           "{{copyright}}{{^copyright}}{{year}}{{^year}}2019{{/year}} {{author-name}}{{^author-name}}Author name here{{/author-name}}{{/copyright}}"

extra-source-files:
- README.md
- ChangeLog.md

# Metadata used when publishing your package
# synopsis:            Short description of your package
# category:            {{category}}{{^category}}Web{{/category}}

# To avoid duplicated efforts in documentation and dealing with the
# complications of embedding Haddock markup inside cabal files, it is
# common to point users to the README.md file.
description:         Please see the README on GitHub at <https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}#readme>

dependencies:
- base >= 4.7 && < 5

library:
  source-dirs: src
  ghc-options:
  # For details on warnings: https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
  # Enable all warnings with -Weverything, then disable the ones we don’t care about
  - -Weverything
  - -Werror
  - -Wno-missing-exported-signatures # missing-exported-signatures turns off the more strict -Wmissing-signatures. See https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
  - -Wno-missing-import-lists # Requires explicit imports of _every_ function (e.g. ‘$’); too strict
  - -Wno-missed-specialisations # When GHC can’t specialize a polymorphic function. No big deal and requires fixing underlying libraries to solve.
  - -Wno-all-missed-specialisations # See missed-specialisations
  - -Wno-unsafe # Don’t use Safe Haskell warnings
  - -Wno-safe # Don’t use Safe Haskell warnings
  - -Wno-missing-local-signatures # Warning for polymorphic local bindings; nothing wrong with those.
  - -Wno-monomorphism-restriction # Don’t warn if the monomorphism restriction is used
  - -Wno-implicit-prelude
  dependencies:
  - hspec
  - hspec-wai

executables:
  {{name}}-exe:
    main:                Main.hs
    source-dirs:         app
    ghc-options:
    # For details on warnings: https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
    # Enable all warnings with -Weverything, then disable the ones we don’t care about
    - -Weverything
    - -Werror
    - -Wno-missing-exported-signatures # missing-exported-signatures turns off the more strict -Wmissing-signatures. See https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
    - -Wno-missing-import-lists # Requires explicit imports of _every_ function (e.g. ‘$’); too strict
    - -Wno-missed-specialisations # When GHC can’t specialize a polymorphic function. No big deal and requires fixing underlying libraries to solve.
    - -Wno-all-missed-specialisations # See missed-specialisations
    - -Wno-unsafe # Don’t use Safe Haskell warnings
    - -Wno-safe # Don’t use Safe Haskell warnings
    - -Wno-missing-local-signatures # Warning for polymorphic local bindings; nothing wrong with those.
    - -Wno-monomorphism-restriction # Don’t warn if the monomorphism restriction is used
    - -Wno-implicit-prelude
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - {{name}}

tests:
  {{name}}-test:
    main:                Spec.hs
    source-dirs:         test
    ghc-options:
    # For details on warnings: https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
    # Enable all warnings with -Weverything, then disable the ones we don’t care about
    - -Weverything
    - -Werror
    - -Wno-missing-exported-signatures # missing-exported-signatures turns off the more strict -Wmissing-signatures. See https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
    - -Wno-missing-import-lists # Requires explicit imports of _every_ function (e.g. ‘$’); too strict
    - -Wno-missed-specialisations # When GHC can’t specialize a polymorphic function. No big deal and requires fixing underlying libraries to solve.
    - -Wno-all-missed-specialisations # See missed-specialisations
    - -Wno-unsafe # Don’t use Safe Haskell warnings
    - -Wno-safe # Don’t use Safe Haskell warnings
    - -Wno-missing-local-signatures # Warning for polymorphic local bindings; nothing wrong with those.
    - -Wno-monomorphism-restriction # Don’t warn if the monomorphism restriction is used
    - -Wno-implicit-prelude
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - {{name}}
    - hspec
    - hspec-wai

{-# START_FILE Setup.hs #-}
import Distribution.Simple
main = defaultMain

{-# START_FILE test/Spec.hs #-}
main :: IO ()
main = putStrLn "Test suite not yet implemented"

{-# START_FILE src/Lib.hs #-}
module Lib
  ( someFunc,
  )
where

someFunc :: IO ()
someFunc = putStrLn "someFunc"

{-# START_FILE app/Main.hs #-}
module Main (main) where

import Lib

main :: IO ()
main = someFunc

{-# START_FILE README.md #-}
# {{name}}

{-# START_FILE ChangeLog.md #-}
# Changelog for {{name}}

## Unreleased changes

{-# START_FILE LICENSE #-}
Copyright {{author-name}}{{^author-name}}Author name here{{/author-name}} (c) {{year}}{{^year}}2019{{/year}}

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of {{author-name}}{{^author-name}}Author name here{{/author-name}} nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

{-# START_FILE .gitignore #-}
.stack-work/
{{name}}.cabal
*~
pkg.nix
nix/pkg.nix
postgres
postgres_data
dist*
postgres.log
result

{-# START_FILE .ignore #-}
.stack-work

{-# START_FILE ./nix/default.nix #-}
{
  pkgs ? null,
  hexOrganization ? null, # organization account name on hex.pm
  hexApiKey ? null,       # plain text account API key on hex.pm
  robotSshKey ? null      # base64-encoded private id_rsa (for private git)
}:
let overlays = [
      (import ./overlay.nix {inherit hexOrganization hexApiKey robotSshKey;})
    ];
    localPkgs = import ./nixpkgs.nix;
    nixpkgs = if pkgs == null then import localPkgs {inherit overlays;} else pkgs;
in
with nixpkgs;

let callPackage = lib.callPackageWith haskellPackages;
    pkg = callPackage ./pkg.nix {inherit stdenv;};
    systemDeps = [ protobuf makeWrapper cacert ];
    testDeps = [ postgresql ];
in
  haskell.lib.overrideCabal pkg (drv: {
    setupHaskellDepends =
      if drv ? "setupHaskellDepends"
      then drv.setupHaskellDepends ++ systemDeps
      else systemDeps;
    testSystemDepends =
      if drv ? "testSystemDepends"
      then drv.testSystemDepends ++ testDeps
      else testDeps;
    isExecutable = true;
    enableSharedExecutables = false;
    enableLibraryProfiling = false;
    isLibrary = false;
    doHaddock = false;
    preCheck = ''
      source ./nix/export-test-envs.sh;
      sh ./nix/reset-test-data.sh;
      sh ./nix/spawn-test-deps.sh;
    '';
    postCheck = ''
      sh ./nix/shutdown-test-deps.sh
    '';
    postFixup = "rm -rf $out/lib $out/nix-support $out/share/doc";
    postInstall = ''
      wrapProgram "$out/bin/{{name}}-exe" \
        --set SYSTEM_CERTIFICATE_PATH "${cacert}/etc/ssl/certs"
    '';
  })

{-# START_FILE ./nix/docker.nix #-}
let nixpkgs = import ./nixpkgs.nix;
in
{
  pkgs ? import nixpkgs {},
  hexOrganization ? null, # organization account name on hex.pm
  hexApiKey ? null,       # plain text account API key on hex.pm
  robotSshKey ? null      # base64-encoded private id_rsa (for private git)
}:
let pkg = import ./default.nix {inherit hexOrganization hexApiKey robotSshKey;};
in
with pkgs;

dockerTools.buildImage {
  name = "{{organization}}{{^organization}}TODO_ADD_ORGANIZATION{{/organization}}/{{name}}";
  contents = [ pkg ];

  config = {
    Cmd = [ "${pkg}/bin/{{name}}-exe" ];
    ExposedPorts = {
      "80/tcp" = {};
    };
  };
}

{-# START_FILE ./nix/nixpkgs.nix #-}
builtins.fetchTarball {
  url="https://github.com/NixOS/nixpkgs/archive/19.09-beta.tar.gz";
  sha256="0fplfm2zx4vk7gs8bdcxnvzkdmpx2w0llqwf8475z9dz9cl132rm";
}

{-# START_FILE ./nix/overlay.nix #-}
{
  hexOrganization,
  hexApiKey,
  robotSshKey
}:
self: super:
  let
    callPackage = self.lib.callPackageWith self.haskellPackages;
    dontCheck = self.haskell.lib.dontCheck;
    doJailbreak = self.haskell.lib.doJailbreak;
    persistent-migration = callPackage ./persistent-migration.nix {
      stdenv = self.stdenv;
      fetchgit = self.fetchgit;
    };
    hspec-wai = callPackage
      ({ mkDerivation, base, base-compat, bytestring, case-insensitive
       , hspec, hspec-core, hspec-expectations, http-types, QuickCheck
       , text, transformers, wai, wai-extra
       }:
       mkDerivation {
         pname = "hspec-wai";
         version = "0.10.1";
         sha256 = "05jv0cz8r8bf63ma5byjb2gkj9vwgnls4n9mks99qc525n055ckz";
         libraryHaskellDepends = [
           base base-compat bytestring case-insensitive hspec-core
           hspec-expectations http-types QuickCheck text transformers wai
           wai-extra
         ];
         testHaskellDepends = [
           base base-compat bytestring case-insensitive hspec hspec-core
           hspec-expectations http-types QuickCheck text transformers wai
           wai-extra
         ];
         description = "Experimental Hspec support for testing WAI applications";
         license = self.stdenv.lib.licenses.mit;
       }) {};
    hspec-wai-json = callPackage
      ({ mkDerivation, aeson, aeson-qq, base, bytestring
       , case-insensitive, hspec, hspec-wai, template-haskell
       }:
       mkDerivation {
         pname = "hspec-wai-json";
         version = "0.10.1";
         sha256 = "04mpqij446ki5l6xwi3bjmlf3ggjia2nzv8j62mdy6ick96dqwk6";
         libraryHaskellDepends = [
           aeson aeson-qq base bytestring case-insensitive hspec-wai
           template-haskell
         ];
         testHaskellDepends = [ base hspec hspec-wai ];
         description = "Testing JSON APIs with hspec-wai";
         license = self.stdenv.lib.licenses.mit;
       }) {};
    scotty = callPackage
      ({ mkDerivation, aeson, async, base, blaze-builder, bytestring
       , case-insensitive, data-default-class, directory, exceptions, fail
       , hspec, hspec-discover, hspec-wai, http-types, lifted-base
       , monad-control, mtl, nats, network, regex-compat, text
       , transformers, transformers-base, transformers-compat, wai
       , wai-extra, warp
       }:
       mkDerivation {
         pname = "scotty";
         version = "0.11.5";
         sha256 = "1pyj7j3zk80lv1c62ccna7nrsql5wf7pi5jscmypr2zd5xgfffvg";
         libraryHaskellDepends = [
           aeson base blaze-builder bytestring case-insensitive
           data-default-class exceptions fail http-types monad-control mtl
           nats network regex-compat text transformers transformers-base
           transformers-compat wai wai-extra warp
         ];
         testHaskellDepends = [
           async base bytestring data-default-class directory hspec hspec-wai
           http-types lifted-base network text wai
         ];
         testToolDepends = [ hspec-discover ];
         description = "Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp";
         license = self.stdenv.lib.licenses.bsd3;
       }) {};
  in
    {
      haskellPackages = super.haskell.packages.ghc865.extend(
        self': super': {
          proto3-suite = dontCheck (doJailbreak super'.proto3-suite);
          hspec-wai = hspec-wai;
          hspec-wai-json = hspec-wai-json;
          scotty = scotty;
          persistent-migration = dontCheck persistent-migration;
        }
      );
    }

{-# START_FILE ./nix/persistent-migration.nix #-}
{ mkDerivation, base, bytestring, conduit, containers, exceptions
, fetchgit, fgl, hpack, monad-logger, mtl, persistent
, persistent-postgresql, persistent-template, process, QuickCheck
, resource-pool, stdenv, tasty, tasty-golden, tasty-quickcheck
, temporary, text, time, unordered-containers, yaml
}:
mkDerivation {
  pname = "persistent-migration";
  version = "0.1.0";
  src = fetchgit {
    url = "https://github.com/coingaming/persistent-migration.git";
    sha256 = "1zs4457q76xxpx1br1xjnh65xcl6bm2zkxjadi92vng7qm7p5z6n";
    rev = "fea2e971b5102f5068021937dbf4ee3bcb42dd1e";
    fetchSubmodules = true;
  };
  libraryHaskellDepends = [
    base containers fgl mtl persistent text time unordered-containers
  ];
  libraryToolDepends = [ hpack ];
  testHaskellDepends = [
    base bytestring conduit containers exceptions monad-logger mtl
    persistent persistent-postgresql persistent-template process
    QuickCheck resource-pool tasty tasty-golden tasty-quickcheck
    temporary text time yaml
  ];
  prePatch = "hpack";
  homepage = "https://github.com/brandonchinn178/persistent-migration#readme";
  description = "Manual migrations for the persistent library";
  license = stdenv.lib.licenses.bsd3;
}

{-# START_FILE ./nix/shell.nix #-}
let nixpkgs = import ./nixpkgs.nix;
in
{
  pkgs ? null,
  hexOrganization ? null, # organization account name on hex.pm
  hexApiKey ? null,       # plain text account API key on hex.pm
  robotSshKey ? null      # base64-encoded private id_rsa (for private git)
}:
let overlays = [
      (import ./overlay.nix {inherit hexOrganization hexApiKey robotSshKey;})
    ];
    pkgs' = if pkgs == null
            then import nixpkgs {inherit overlays;}
            else pkgs;
in
with pkgs';

let haskell-ide = import (
      fetchTarball "https://github.com/tim2CF/ultimate-haskell-ide/tarball/master"
    ) {};
in

stdenv.mkDerivation {
  name = "{{name}}-env";
  buildInputs = [
    /* IDE */
    haskell-ide
    /* Apps */
    postgresql
    /* Utils */
    git
    nix-prefetch-scripts
    openssh
    cabal2nix
    protobuf
    cacert
    xxd
  ];

  TERM="xterm-256color";
  GIT_SSL_CAINFO="${cacert}/etc/ssl/certs/ca-bundle.crt";
  NIX_SSL_CERT_FILE="${cacert}/etc/ssl/certs/ca-bundle.crt";
  NIX_PATH="/nix/var/nix/profiles/per-user/root/channels";
  HEX_ORGANIZATION=hexOrganization;
  HEX_API_KEY=hexApiKey;
  ROBOT_SSH_KEY=robotSshKey;
  shellHook = ''
    source ./nix/export-test-envs.sh
    sh ./nix/reset-test-data.sh
    sh ./nix/spawn-test-deps.sh

    export HOOGLEDB=/root/.hoogle
    if [ "$(ls -A $HOOGLEDB)" ]; then
      echo "hoogle database already exists..."
    else
      echo "building hoogle database..."
      stack --stack-yaml=/app/stack.yaml exec hoogle generate
    fi
  '';
}

{-# START_FILE ./nix/bootstrap.sh #-}
#/bin/sh

set -e

export PATH=/nix/var/nix/profiles/default/bin:/nix/var/nix/profiles/default/sbin:$PATH

# Disable HTTP2 (related to https://github.com/NixOS/nix/issues/2733)
echo 'http2 = false' >> /etc/nix/nix.conf
nix-channel --add https://nixos.org/channels/nixos-19.09 nixpkgs
nix-channel --update
nix-env -iAP nixpkgs.openssh nixpkgs.git nixpkgs.cabal2nix nixpkgs.coreutils nixpkgs.docker
nix-env -iAP cachix -f https://cachix.org/api/v1/install
cachix use all-hies

mkdir -p /tmp/.ssh/
mkdir -p $HOME/.ssh/
echo "$ROBOT_SSH_KEY" | base64 -d > /tmp/.ssh/id_rsa.robot
chmod 600 /tmp/.ssh/id_rsa.robot
eval `ssh-agent -s`
ssh-add /tmp/.ssh/id_rsa.robot
echo -e "Host *\n IdentityFile /tmp/.ssh/id_rsa.robot\n IdentitiesOnly yes\n UserKnownHostsFile /tmp/.ssh/known_hosts\n StrictHostKeyChecking no" > /tmp/.ssh/config
ssh-keyscan github.com >> /tmp/.ssh/known_hosts
cp /tmp/.ssh/* $HOME/.ssh/
echo -e "Host *\n IdentityFile $HOME/.ssh/id_rsa.robot\n IdentitiesOnly yes\n UserKnownHostsFile $HOME/.ssh/known_hosts\n StrictHostKeyChecking no" > $HOME/.ssh/config
chown -R nixbld1 /tmp/.ssh/
git submodule update --init --recursive --depth 1

{-# START_FILE ./nix/export-test-envs.sh #-}
#!/bin/sh

#
# app
#

export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_ENV="dev";
export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_LOG_FORMAT="Bracket"; # Bracket | JSON
export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_LIBPQ_CONN_STR="postgresql://nixbld1@localhost/{{name}}";
export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_ENDPOINT_PORT="4000";

{-# START_FILE ./nix/release.sh #-}
#!/bin/sh

set -e

./nix/bootstrap.sh

(cd ./nix/ && cabal2nix ./.. > ./pkg.nix)

NIXPKGS_ALLOW_BROKEN=1 nix-build ./nix/docker.nix \
  -I ssh-config-file=/tmp/.ssh/config \
  --argstr hexOrganization tkachuk.labs \
  --argstr hexApiKey $HEX_API_KEY \
  --argstr robotSshKey $ROBOT_SSH_KEY \
  --option sandbox false \
  -v --show-trace

{-# START_FILE ./nix/reset-test-data.sh #-}
#!/bin/sh

echo "resetting dev data..."
rm -rf $PGDATA
echo "dev data has been reset!"

{-# START_FILE ./nix/shell.sh #-}
#!/bin/sh

export IP=$(ifconfig en0 | grep inet | awk '$1=="inet" {print $2}')
echo "host is $IP"
echo "starting nixos container..."
# enable for GUI apps
# xhost + $IP
docker run -it --rm \
  -e DISPLAY=$IP:0 \
  -e NIXPKGS_ALLOW_BROKEN=1 \
  -e ROBOT_SSH_KEY="$ROBOT_SSH_KEY" \
  -v "$(pwd):/app" \
  -v "nix:/nix" \
  -v "stack:/root/.stack" \
  -v "cabal:/root/.cabal" \
  -v "hoogle:/root/.hoogle" \
  -w "/app" nixos/nix:2.3 sh -c "
  ./nix/bootstrap.sh &&
  nix-shell ./nix/shell.nix --pure \
   -I ssh-config-file=/tmp/.ssh/config \
   --argstr hexOrganization $HEX_ORGANIZATION \
   --argstr hexApiKey $HEX_API_KEY \
   --argstr robotSshKey $ROBOT_SSH_KEY \
   --option sandbox false \
   -v --show-trace
  "

{-# START_FILE ./nix/shutdown-test-deps.sh #-}
#!/bin/sh

set -m

export PATH=$PATH:/bin/
export PGDATA=$PWD/postgres
export PGHOST=/tmp/postgres
export PGLOG=$PWD/postgres/LOG
export PGDATABASE=postgres
export DATABASE_URL="postgresql:///postgres?host=$PGHOST"

#
# Postgres
#

if [[ $EUID -ne 0 ]]; then
    alias postgres-sh="sh"
else
    alias postgres-sh="su -m nixbld1"
fi

echo "shutdown postgres..."
postgres-sh -c 'pg_ctl stop -o "-c unix_socket_directories=$PGHOST"'
echo "shutdown hook executed"

{-# START_FILE ./nix/spawn-test-deps.sh #-}
#!/bin/sh

set -m

export PATH=$PATH:/bin/
export PGDATA=$PWD/postgres
export PGHOST=/tmp/postgres
export PGLOG=$PWD/postgres/LOG
export PGDATABASE=postgres
export DATABASE_URL="postgresql:///postgres?host=$PGHOST"

#
# Postgres
#

if [[ $EUID -ne 0 ]]; then
    alias postgres-sh="sh"
else
    alias postgres-sh="su -m nixbld1"
fi

if [ ! -d $PGHOST ]; then
  echo 'initializing postgresql workspace...'
  postgres-sh -c "mkdir -p $PGHOST"
fi
if [ ! -d $PGDATA ]; then
  echo 'initializing postgresql database...'
  postgres-sh -c "mkdir -p $PGDATA"
  postgres-sh -c 'initdb $PGDATA --encoding=UTF8 --auth=trust >/dev/null'
fi

echo "starting postgres..."
postgres-sh -c 'pg_ctl start -o "-c listen_addresses=localhost -c unix_socket_directories=$PGHOST"'

# NOTE : some Postgres bullshit - it crashes if createdb is executed too soon
echo "sleeping for 3s to prevent postgres/createdb race condition..."
sleep 3

postgres-sh -c 'createdb {{name}}'
echo "spawn-test-deps executed"

{-# START_FILE hie.yaml #-}
cradle:
  stack:

{-# START_FILE .vim/coc-settings.json #-}
{
    "languageserver": {
        "haskell": {
            "command": "hie-wrapper",
            "rootPatterns": [
                "*.cabal",
                "stack.yaml",
                "cabal.project",
                "package.yaml"],
                "filetypes": [
                    "hs",
                    "lhs",
                    "haskell"
                ],
                "initializationOptions": {
                    "languageServerHaskell": {
                    }
                }
        }
    }
}

{-# START_FILE .circleci/config.yml #-}
configure: &configure
  docker:
  - image: nixos/nix:2.3
  resource_class: xlarge

release: &release
  run:
    name: Create release
    command: ./nix/release.sh
    no_output_timeout: 60m

filters: &filters
  filters:
    branches: {}

version: 2
jobs:
  release:
    <<: *configure
    steps:
    - checkout
    - setup_remote_docker
    - *release
  release-publish:
    <<: *configure
    steps:
    - checkout
    - setup_remote_docker
    - *release
    - run:
        name: Load docker image
        command: docker load -i result
    - run:
        name: Login docker
        command: echo -e "$DOCKER_PASS" | docker login -u $DOCKER_USER --password-stdin
    - run:
        name: Push docker image
        command: docker push "$(docker images {{organization}}{{^organization}}TODO_ADD_ORGANIZATION{{/organization}}/{{name}} --format "{{=<% %>=}}{{.Repository}}:{{.Tag}}<%={{ }}=%>")"

workflows:
  version: 2
  nightly:
    triggers:
      - schedule:
          <<: *filters
          cron: "0 5 * * *"  # 05:00 UTC
    jobs:
      - release:
          <<: *filters
          context: global
  push:
    jobs:
      - release-publish:
          <<: *filters
          context: global
