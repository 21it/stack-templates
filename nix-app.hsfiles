{-# START_FILE package.yaml #-}
name:                {{name}}
version:             0.1.0.0
github:              "{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}"
license:             BSD3
author:              "{{author-name}}{{^author-name}}Author name here{{/author-name}}"
maintainer:          "{{author-email}}{{^author-email}}example@example.com{{/author-email}}"
copyright:           "{{copyright}}{{^copyright}}{{year}}{{^year}}2019{{/year}} {{author-name}}{{^author-name}}Author name here{{/author-name}}{{/copyright}}"

extra-source-files:
- README.md
- ChangeLog.md

# Metadata used when publishing your package
# synopsis:            Short description of your package
# category:            {{category}}{{^category}}Web{{/category}}

# To avoid duplicated efforts in documentation and dealing with the
# complications of embedding Haddock markup inside cabal files, it is
# common to point users to the README.md file.
description:         Please see the README on GitHub at <https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}#readme>

dependencies:
- base >= 4.7 && < 5

library:
  source-dirs: src
  ghc-options:
  # For details on warnings: https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
  # Enable all warnings with -Weverything, then disable the ones we don’t care about
  - -Weverything
  - -Werror
  - -Wno-missing-exported-signatures # missing-exported-signatures turns off the more strict -Wmissing-signatures. See https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
  - -Wno-missing-import-lists # Requires explicit imports of _every_ function (e.g. ‘$’); too strict
  - -Wno-missed-specialisations # When GHC can’t specialize a polymorphic function. No big deal and requires fixing underlying libraries to solve.
  - -Wno-all-missed-specialisations # See missed-specialisations
  - -Wno-unsafe # Don’t use Safe Haskell warnings
  - -Wno-safe # Don’t use Safe Haskell warnings
  - -Wno-missing-local-signatures # Warning for polymorphic local bindings; nothing wrong with those.
  - -Wno-monomorphism-restriction # Don’t warn if the monomorphism restriction is used
  - -Wno-implicit-prelude
  dependencies:
  - hspec
  - hspec-wai

executables:
  {{name}}-exe:
    main:                Main.hs
    source-dirs:         app
    ghc-options:
    # For details on warnings: https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
    # Enable all warnings with -Weverything, then disable the ones we don’t care about
    - -Weverything
    - -Werror
    - -Wno-missing-exported-signatures # missing-exported-signatures turns off the more strict -Wmissing-signatures. See https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
    - -Wno-missing-import-lists # Requires explicit imports of _every_ function (e.g. ‘$’); too strict
    - -Wno-missed-specialisations # When GHC can’t specialize a polymorphic function. No big deal and requires fixing underlying libraries to solve.
    - -Wno-all-missed-specialisations # See missed-specialisations
    - -Wno-unsafe # Don’t use Safe Haskell warnings
    - -Wno-safe # Don’t use Safe Haskell warnings
    - -Wno-missing-local-signatures # Warning for polymorphic local bindings; nothing wrong with those.
    - -Wno-monomorphism-restriction # Don’t warn if the monomorphism restriction is used
    - -Wno-implicit-prelude
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - {{name}}

tests:
  {{name}}-test:
    main:                Spec.hs
    source-dirs:         test
    ghc-options:
    # For details on warnings: https://downloads.haskell.org/~ghc/master/users-guide/using-warnings.html
    # Enable all warnings with -Weverything, then disable the ones we don’t care about
    - -Weverything
    - -Werror
    - -Wno-missing-exported-signatures # missing-exported-signatures turns off the more strict -Wmissing-signatures. See https://ghc.haskell.org/trac/ghc/ticket/14794#ticket
    - -Wno-missing-import-lists # Requires explicit imports of _every_ function (e.g. ‘$’); too strict
    - -Wno-missed-specialisations # When GHC can’t specialize a polymorphic function. No big deal and requires fixing underlying libraries to solve.
    - -Wno-all-missed-specialisations # See missed-specialisations
    - -Wno-unsafe # Don’t use Safe Haskell warnings
    - -Wno-safe # Don’t use Safe Haskell warnings
    - -Wno-missing-local-signatures # Warning for polymorphic local bindings; nothing wrong with those.
    - -Wno-monomorphism-restriction # Don’t warn if the monomorphism restriction is used
    - -Wno-implicit-prelude
    - -threaded
    - -rtsopts
    - -with-rtsopts=-N
    dependencies:
    - {{name}}
    - hspec
    - hspec-wai

{-# START_FILE Setup.hs #-}
import Distribution.Simple
main = defaultMain

{-# START_FILE test/Spec.hs #-}
main :: IO ()
main = putStrLn "Test suite not yet implemented"

{-# START_FILE src/Lib.hs #-}
module Lib
    ( someFunc
    ) where

someFunc :: IO ()
someFunc = putStrLn "someFunc"

{-# START_FILE app/Main.hs #-}
module Main where

import Lib

main :: IO ()
main = someFunc

{-# START_FILE README.md #-}
# {{name}}

{-# START_FILE ChangeLog.md #-}
# Changelog for {{name}}

## Unreleased changes

{-# START_FILE LICENSE #-}
Copyright {{author-name}}{{^author-name}}Author name here{{/author-name}} (c) {{year}}{{^year}}2019{{/year}}

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of {{author-name}}{{^author-name}}Author name here{{/author-name}} nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

{-# START_FILE .gitignore #-}
.stack-work/
{{name}}.cabal
*~
pkg.nix
postgres/
dist*
result

{-# START_FILE default.nix #-}
let overlays = [(import ./overlay.nix)];
in
{ pkgs ? import <nixpkgs-unstable> {inherit overlays;} }:
with pkgs;

/*  */
/* TODO : minimize docker image size */
/*  */

let callPackage = lib.callPackageWith haskellPackages;
    pkg = callPackage ./pkg.nix {inherit stdenv;};
    systemDeps = [ protobuf makeWrapper cacert ];
    testDeps = [ postgresql ];
in

haskell.lib.overrideCabal pkg (drv: {
  setupHaskellDepends = if drv ? "setupHaskellDepends" then drv.setupHaskellDepends ++ systemDeps else systemDeps;
  testSystemDepends = if drv ? "testSystemDepends" then drv.testSystemDepends ++ testDeps else testDeps;
  isExecutable = true;
  enableSharedExecutables = false;
  enableLibraryProfiling = false;
  isLibrary = false;
  preCheck  = ''
    source ./export-dev-envs.sh;
    sh ./reset-dev-data.sh;
    sh ./spawn-dev-deps.sh;
  '';
  doHaddock = false;
  postFixup = "rm -rf $out/lib $out/nix-support $out/share/doc";
  postInstall = ''
    wrapProgram "$out/bin/{{name}}-exe" \
      --set SYSTEM_CERTIFICATE_PATH "${cacert}/etc/ssl/certs"
  '';
})

{-# START_FILE docker.nix #-}
let pkg = import ./. {};
in

{ pkgs ? import <nixpkgs> {} }:
with pkgs;

dockerTools.buildImage {
  name = "{{organization}}{{^organization}}TODO_ADD_ORGANIZATION{{/organization}}/{{name}}";
  contents = [ pkg ];

  config = {
    Cmd = [ "${pkg}/bin/{{name}}-exe" ];
    ExposedPorts = {
      "80/tcp" = {};
    };
  };
}

{-# START_FILE export-dev-envs.sh #-}
#!/bin/sh

#
# postgres
#

export PATH=$PATH:/bin/
export PGDATA=$PWD/postgres
export PGHOST=/tmp/postgres
export PGLOG=$PWD/postgres/LOG
export PGDATABASE=postgres
export DATABASE_URL="postgresql:///postgres?host=$PGHOST"

#
# app
#

export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_ENV="dev";
export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_LOG_FORMAT="Bracket"; # Bracket | JSON
export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_LIBPQ_CONN_STR="postgresql://nixbld1@/{{name}}";
export {{env-prefix}}{{^env-prefix}}TODO_ADD_ENV_PREFIX{{/env-prefix}}_ENDPOINT_PORT="4000";

{-# START_FILE hie.yaml #-}
cradle:
  stack:

{-# START_FILE nix-shell.sh #-}
#!/bin/sh

export IP=$(ifconfig en0 | grep inet | awk '$1=="inet" {print $2}')
echo "host is $IP"
echo "starting nixos container..."
# enable for GUI apps
# xhost + $IP
docker run -it --rm \
  -e DISPLAY=$IP:0 \
  -e NIXPKGS_ALLOW_BROKEN=1 \
  -v "$(pwd):/app" \
  -v "nix:/nix" \
  -v "stack:/root/.stack" \
  -v "cabal:/root/.cabal" \
  -v "hoogle:/root/.hoogle" \
  -w "/app" nixos/nix:2.3 sh -c "
  nix-channel --add https://nixos.org/channels/nixos-19.09 nixpkgs &&
  nix-channel --add https://nixos.org/channels/nixpkgs-unstable nixpkgs-unstable &&
  nix-channel --update &&
  nix-env -iA cachix -f https://cachix.org/api/v1/install &&
  cachix use all-hies &&
  nix-shell --pure
  "

{-# START_FILE overlay.nix #-}
self: super:
  let
    unstable = import <nixpkgs-unstable> {};
    callPackage = self.lib.callPackageWith self.haskellPackages;
    dontCheck = self.haskell.lib.dontCheck;
    doJailbreak = self.haskell.lib.doJailbreak;
    persistent-migration = callPackage ./persistent-migration.nix {
      stdenv = self.stdenv;
      fetchgit = self.fetchgit;
    };
  in
    {
      haskellPackages = super.haskell.packages.ghc865.extend(
        self': super': {
          proto3-suite = dontCheck (doJailbreak super'.proto3-suite);
          hspec-wai = unstable.haskellPackages.hspec-wai_0_10_1;
          hspec-wai-json = unstable.haskellPackages.hspec-wai-json_0_10_1;
          scotty = unstable.haskellPackages.scotty;
          ormolu = unstable.haskellPackages.ormolu;
          persistent-migration = dontCheck persistent-migration;
        }
      );
    }

{-# START_FILE persistent-migration.nix #-}
{ mkDerivation, base, bytestring, conduit, containers, exceptions
, fetchgit, fgl, hpack, monad-logger, mtl, persistent
, persistent-postgresql, persistent-template, process, QuickCheck
, resource-pool, stdenv, tasty, tasty-golden, tasty-quickcheck
, temporary, text, time, unordered-containers, yaml
}:
mkDerivation {
  pname = "persistent-migration";
  version = "0.1.0";
  src = fetchgit {
    url = "https://github.com/coingaming/persistent-migration.git";
    sha256 = "1zs4457q76xxpx1br1xjnh65xcl6bm2zkxjadi92vng7qm7p5z6n";
    rev = "fea2e971b5102f5068021937dbf4ee3bcb42dd1e";
    fetchSubmodules = true;
  };
  libraryHaskellDepends = [
    base containers fgl mtl persistent text time unordered-containers
  ];
  libraryToolDepends = [ hpack ];
  testHaskellDepends = [
    base bytestring conduit containers exceptions monad-logger mtl
    persistent persistent-postgresql persistent-template process
    QuickCheck resource-pool tasty tasty-golden tasty-quickcheck
    temporary text time yaml
  ];
  prePatch = "hpack";
  homepage = "https://github.com/brandonchinn178/persistent-migration#readme";
  description = "Manual migrations for the persistent library";
  license = stdenv.lib.licenses.bsd3;
}

{-# START_FILE reset-dev-data.sh #-}
#!/bin/sh

echo "resetting dev data..."
rm -rf $PGDATA
echo "dev data has been reset!"

{-# START_FILE shell.nix #-}
let overlays = [(import ./overlay.nix)];
in

{ pkgs ? import <nixpkgs> {inherit overlays;} }:
with pkgs;

let haskell-ide = import (fetchTarball "https://github.com/tim2CF/ultimate-haskell-ide/tarball/master") {inherit pkgs;};
in

stdenv.mkDerivation {
  name = "{{name}}-env";
  buildInputs = [
    /* IDE */
    haskell-ide
    /* Apps */
    postgresql
    /* Utils */
    cacert
  ];

  TERM="xterm-256color";
  NIX_SSL_CERT_FILE = "${cacert}/etc/ssl/certs/ca-bundle.crt";
  shellHook = ''
    source ./export-dev-envs.sh
    sh ./reset-dev-data.sh
    sh ./spawn-dev-deps.sh

    export HOOGLEDB=/root/.hoogle
    if [ "$(ls -A $HOOGLEDB)" ]; then
      echo "hoogle database already exists..."
    else
      echo "building hoogle database..."
      stack --stack-yaml=/app/stack.yaml exec hoogle generate
    fi
  '';
}

{-# START_FILE spawn-dev-deps.sh #-}
#!/bin/sh

set -m

#
# Postgres
#

if [[ $EUID -ne 0 ]]; then
    alias postgres-sh="sh"
else
    alias postgres-sh="su -m nixbld1"
fi

if [ ! -d $PGHOST ]; then
  echo 'initializing postgresql workspace...'
  postgres-sh -c "mkdir -p $PGHOST"
fi
if [ ! -d $PGDATA ]; then
  echo 'initializing postgresql database...'
  postgres-sh -c 'initdb $PGDATA --auth=trust >/dev/null'
fi
echo "starting postgres..."
postgres-sh -c 'pg_ctl start -l $PGLOG -o "-c listen_addresses= -c unix_socket_directories=$PGHOST"'

# NOTE : some Postgres bullshit - it crashes if createdb is executed too soon
echo "sleeping for 3s to prevent postgres/createdb race condition..."
sleep 3;

postgres-sh -c 'createdb {{name}}'

#
# done
#

echo "shell hook executed!"

{-# START_FILE .vim/coc-settings.json #-}
{
    "languageserver": {
        "haskell": {
            "command": "hie-wrapper",
            "rootPatterns": [
                "*.cabal",
                "stack.yaml",
                "cabal.project",
                "package.yaml"],
                "filetypes": [
                    "hs",
                    "lhs",
                    "haskell"
                ],
                "initializationOptions": {
                    "languageServerHaskell": {
                    }
                }
        }
    }
}

{-# START_FILE .circleci/config.yml #-}
configure: &configure
  docker:
  - image: nixos/nix:2.3
  resource_class: xlarge

release: &release
  run:
    name: Create release
    command: ./.circleci/release.sh
    no_output_timeout: 60m

filters: &filters
  filters:
    branches:
      only:
        - master

version: 2
jobs:
  release:
    <<: *configure
    steps:
    - checkout
    - setup_remote_docker
    - *release
  release-publish:
    <<: *configure
    steps:
    - checkout
    - setup_remote_docker
    - *release
    - run:
        name: Load docker image
        command: docker load -i result
    - run:
        name: Login docker
        command: echo -e "$DOCKER_PASS" | docker login -u $DOCKER_USER --password-stdin
    - run:
        name: Push docker image
        command: docker push "$(docker images {{organization}}{{^organization}}TODO_ADD_ORGANIZATION{{/organization}}/{{name}} --format "{{.Repository}}:{{.Tag}}")"

workflows:
  version: 2
  nightly:
    triggers:
      - schedule:
          <<: *filters
          cron: "0 5 * * *"  # 05:00 UTC
    jobs:
      - release:
          <<: *filters
          context: global
  push:
    jobs:
      - release-publish:
          <<: *filters
          context: global

{-# START_FILE .circleci/release.sh #-}
#!/bin/sh

set -e

# Disable HTTP2 (related to https://github.com/NixOS/nix/issues/2733)
echo 'http2 = false' >> /etc/nix/nix.conf
nix-channel --add https://nixos.org/channels/nixos-19.09 nixpkgs
nix-channel --add https://nixos.org/channels/nixpkgs-unstable nixpkgs-unstable
nix-channel --update
nix-env -iA nixpkgs.openssh nixpkgs.git nixpkgs.docker nixpkgs.cabal2nix
cabal2nix . > pkg.nix
# cabal2nix https://github.com/coingaming/persistent-migration.git > persistent-migration.nix
# cabal2nix https://github.com/coingaming/HaskellNet.git > haskell-net.nix
mkdir -p $HOME/.ssh/
echo "$ROBOT_SSH_KEY" | base64 -d > $HOME/.ssh/id_rsa.robot && chmod 600 $HOME/.ssh/id_rsa.robot && ssh-add $HOME/.ssh/id_rsa.robot
echo -e "Host *\n IdentityFile $HOME/.ssh/id_rsa.robot\n IdentitiesOnly yes" > $HOME/.ssh/config
ssh-keyscan github.com >> $HOME/.ssh/known_hosts
# git submodule foreach git pull && git submodule update --init --recursive
NIXPKGS_ALLOW_BROKEN=1 nix-build docker.nix
